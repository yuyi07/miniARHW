<!DOCTYPE html>
<html>
<head>
<style>
#heading{
	 position:absolute;
	 text-align:center;
	 width:100vw;
}		
</style> 
</head>
<body> 
	<div id = heading>
		<div id="info">Cannon Firing</div>
	</div>
<script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
<script src="https://jyunming-chen.github.io/tutsplus/js/KeyboardState.js"></script>
<script type = "module">

import * as THREE from "https://threejs.org/build/three.module.js";
import { OrbitControls } from "https://threejs.org/examples/jsm/controls/OrbitControls.js";

var camera, scene, renderer;
var cannon;
var clock;
var ball = [], x0, dx;
var i = 1;
var nowPos, prePos;
var pos, vel, force;
var keyboard = new KeyboardState();
var angle = 0;

init();
animate();

function init() {

	scene = new THREE.Scene();

	renderer = new THREE.WebGLRenderer();
	renderer.setSize(window.innerWidth, window.innerHeight);
	renderer.setClearColor(0x888888);
	document.body.appendChild(renderer.domElement);

	camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 1000);
	camera.position.set(0, 150, 150);
	let controls = new OrbitControls(camera, renderer.domElement);
	var gridXZ = new THREE.GridHelper(200, 20, 'red', 'white');
	scene.add(gridXZ);
  
  /////////////////////////////////////////////////////////////////////
	cannon = makeCannon();
	scene.add(cannon);
	ball = new THREE.Mesh(new THREE.SphereGeometry(2, 8, 8), new THREE.MeshBasicMaterial({
		color: 'yellow',
		wireframe: true
	}));
	scene.add(ball);

	clock = new THREE.Clock();

	//// settings //////////////////////
	let barrel = cannon.children[1]
	barrel.rotation.z = -Math.PI / 6; // barrel angle
	cannon.rotation.y = -Math.PI / 6;
  
	scene.add (makeParabola (-.125, 4, 30));
  
  ///// two end points
  // x0 = b - sqrt(-c/a)
  // x1 = b + sqrt(-c/a)
  // y = a(x-b)^2 + c
	x0 = 4 - Math.sqrt(30/.125);
  dx = 2*Math.sqrt(30/.125);
  

  nowPos = new THREE.Vector3();
  prePos = new THREE.Vector3();
  prePos.set (x0,0,0);
}

function onWindowResize() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);

}


function makeCannon() {
  let cannon = new THREE.Group();
  let body = new THREE.Mesh(new THREE.SphereGeometry(
    10, 20, 20, Math.PI + Math.PI * 0.1, Math.PI * 1.8, 0, Math.PI / 2), new THREE.MeshNormalMaterial());
  let barrelPart = new THREE.Group();
  let barrel = new THREE.Mesh(new THREE.CylinderGeometry(2, 2, 20, 18), new THREE.MeshNormalMaterial());
  barrelPart.add(barrel);
  barrel.position.y = 10;

  cannon.add(body, barrelPart);
  return cannon;
}

function computeInitPosVel() {
  let barrel = cannon.children[1];
  const SPEED = 25;
  vel = barrel.localToWorld(new THREE.Vector3(0, 20, 0)).sub(
    barrel.localToWorld(new THREE.Vector3(0, 0, 0))).setLength(SPEED);
  pos = barrel.localToWorld(new THREE.Vector3(0, 22, 0));
  force = new THREE.Vector3(0, -10, 0);
}

function update() {

  keyboard.update();
  if (keyboard.pressed("left"))
    cannon.rotation.y += 0.1;
  if (keyboard.pressed("right"))
    cannon.rotation.y -= 0.1;
  if (keyboard.pressed("up")) {
    	cannon.children[1].rotation.z += 0.1;
  }

  if (keyboard.pressed("down")) {
    	cannon.children[1].rotation.z -= 0.1;
  }

}



function makeParabola (a, b, c) {
	let xRange = Math.sqrt(-a*c)*2/a;
  const N = 20;
  let dx = xRange/20;
  
  let points = [];
  let x0 = b - xRange/2;
  for (let i = 0; i <= N; i++) {
  	let xi = x0 + i*dx;
    let yi = a*(xi-b)*(xi-b) + c;
    points.push (new THREE.Vector3(xi,yi,0));
  }
  
  let geometry = new THREE.BufferGeometry().setFromPoints(points);
  let parabola = new THREE.Line (geometry, new THREE.LineDashedMaterial({color:'cyan'}));
  parabola.computeLineDistances(); // required for LineDashedMaterial
  return parabola;
  
}
function animate() {
  	requestAnimationFrame(animate);
  	render();

	var dt = clock.getDelta();
	update();

	if (keyboard.down("space")){
		if (pos === undefined) {
			computeInitPosVel();
			return;
		}

	}		
	if (pos.y < 0)
		return;

			// Euler's method
		vel.add(force.clone().multiplyScalar(dt));
		pos.add(vel.clone().multiplyScalar(dt));
		ball.position.copy(pos);
	

	
	let xi = x0 + i*dx/100;
	let yi = -.125*(xi-4)*(xi-4)+30;
		if (i > 100) {
		//console.log (yi)
		return;
	}
	prePos.copy (nowPos);
	nowPos.set (xi, yi, 0);
	//ball.position.copy (nowPos);
	ball.quaternion.setFromUnitVectors(new THREE.Vector3(0,1,0), nowPos.clone().sub(prePos).normalize());
	
	++i;


}

function render() {

  renderer.render(scene, camera);

}


</script>

</body>
</html>